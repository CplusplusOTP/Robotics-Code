{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor LeftMotor = motor(PORT12, ratio18_1, false);\n\nmotor RightMotor = motor(PORT19, ratio18_1, true);\n\ninertial Balance = inertial(PORT20);\n\nsonar DistanceSensor = sonar(Brain.ThreeWirePort.A);\nsonar DistanceSensor2 = sonar(Brain.ThreeWirePort.G);\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n//change your targetAngle, length to center of mass and possibly your wheel circumference\nconst double CIRCUMFERENCE = 4.0*0.0254*M_PI;//4\" wheel to m\ndouble targetAngle = 0.6;//in degrees - so is the sensor for measuring error state\ndouble l = 0.65;//length of (uniform) beam ie. your pendulum\ndouble m = 2.3944;//mass of pendulum\ndouble mC = 0.9584;//mass of the cart\ndouble M = m + mC;\n\n//all units are in radians\nconst double MAX_TILT = M_PI/6;//30 degrees\nconst double MAX_VELOCITY = 1;//1m/s\nconst double RPM_TO_MPS = CIRCUMFERENCE/60.0;//PI * diameter in m\nconst double DEGREES_TO_RADIANS = M_PI / 180.0;\nconst double dt = 0.01;//10ms for motor pid to react (200Hz)\nconst double dtSqr = dt*dt;\nconst double G = 9.81;\n\n//K = {position, velocity, angle, angular velocity}\n//make sure your sensor values match the implied response\n//For example, if a positive angle has a positive gain then forward (positive) should be the correct direction for restoring equilibrium\nconst int POSITION = 0;\nconst int VELOCITY = 1;\nconst int ANGLE = 2;\nconst int ANGULAR_VELOCITY = 3;\nconst int STATES = 4;\nconst int OUTPUTS = 1;\ndouble gains[STATES] = {0, 0, 0, 0};\n\ndouble actualState[STATES] = {0, 0, 0, 0};\ndouble desiredState[STATES] = {0, 0, targetAngle*DEGREES_TO_RADIANS, 0};\ndouble errorState[STATES] = {0, 0, 0, 0};\n\ndouble A[STATES*STATES];\ndouble At[STATES*STATES];\ndouble B[STATES*OUTPUTS];\ndouble Bt[OUTPUTS*STATES];\n\ndouble maxP = 0.01;\ndouble maxV = 0.01;\ndouble maxA = 0.1*M_PI/180;\ndouble maxAV = 20*maxA;\ndouble Q[STATES*STATES] = {  \n                    1/(maxP*maxP), 0, 0, 0, \n                    0, 1/(maxV*maxV), 0, 0,\n                    0, 0, 1/(maxA*maxA), 0,\n                    0, 0, 0, 1/(maxAV*maxAV)};\n\ndouble maxAcc = 25*RPM_TO_MPS;\ndouble R[OUTPUTS*OUTPUTS] = { 1/(maxAcc*maxAcc) };\n\n//adapted from https://sharpneat.sourceforge.io/research/cart-pole/cart-pole-equations.html\n//equations (27 & 28 k = 1/3 no friction)\nvoid updateStateSpace()\n{\n    //recalculate state matrices\n    double theta = errorState[ANGLE];//-pi/2 to pi/2 becomes -pi/12 to pi/12\n    double thetaDot = errorState[ANGULAR_VELOCITY];\n    \n    double j,k,den,p,q,r;\n    if(fabs(errorState[ANGLE]) < 1e-7)//sin(theta)/theta -> 1\n    {\n        j = 3*G/(4*l);\n        k = 3*cos(theta)/(4*l);\n        den = m*cos(theta)*cos(theta)-4*M/3.0;\n        p = m*G*cos(theta)/den;\n        q = 4*mC/(3*den);\n        r = 4*m*l*thetaDot*sin(theta)/(3*den);\n    }\n\n    else\n    {\n        j = 3*G*sin(theta)/(4*l*theta);\n        k = 3*cos(theta)/(4*l);\n        den = m*cos(theta)*cos(theta)-4*M/3.0;\n        p = m*G*sin(theta)*cos(theta)/(theta*den);\n        q = 4*mC/(3*den);\n        r = 4*m*l*thetaDot*sin(theta)/(3*den);\n    }\n\n    /*\n        error -r*thetaDot*dt should just be -r*dt\n        double tempA[STATES*STATES] = {   \n                    1, dt, 0.5*p*dtSqr, -0.5*r*dtSqr,\n                    0, 1, p*dt, -r*thetaDot*dt,\n                    0, 0, 1+(0.5*j-0.5*k*p)*dtSqr, dt+0.5*k*r*dtSqr,\n                    0, 0, (j-k*p)*dt, 1+k*r*dt};\n\n        double tempAt[STATES*STATES] = {\n                    1, 0, 0, 0,\n                    dt, 1, 0, 0,\n                    0.5*p*dtSqr, p*dt, 1+(0.5*j-0.5*k*p)*dtSqr, (j-k*p)*dt,\n                    -0.5*r*dtSqr, -r*thetaDot*dt, dt+0.5*k*r*dtSqr, 1+k*r*dt};\n                    */\n    double tempA[STATES*STATES] = {   \n                    1, dt, 0.5*p*dtSqr, -0.5*r*dtSqr,\n                    0, 1, p*dt, -r*dt,\n                    0, 0, 1+(0.5*j-0.5*k*p)*dtSqr, dt+0.5*k*r*dtSqr,\n                    0, 0, (j-k*p)*dt, 1+k*r*dt};\n\n    double tempAt[STATES*STATES] = {\n                    1, 0, 0, 0,\n                    dt, 1, 0, 0,\n                    0.5*p*dtSqr, p*dt, 1+(0.5*j-0.5*k*p)*dtSqr, (j-k*p)*dt,\n                    -0.5*r*dtSqr, -r*dt, dt+0.5*k*r*dtSqr, 1+k*r*dt};\n                                \n    double tempB[STATES*OUTPUTS] = {   \n                    -0.5*q*dtSqr,\n                    -q*dt,\n                    0.5*k*q*dtSqr,\n                    k*q*dt};\n    double tempBt[OUTPUTS*STATES] = { -0.5*q*dtSqr, -q*dt, 0.5*k*q*dtSqr, k*q*dt};\n    \n    memcpy(A, tempA, STATES*STATES*sizeof(double));\n    memcpy(At, tempAt, STATES*STATES*sizeof(double));                            \n    memcpy(B, tempB, STATES*OUTPUTS*sizeof(double));\n    memcpy(Bt, tempBt, OUTPUTS*STATES*sizeof(double));\n}\n\nvoid add(double* a, double* b, double* sum, int r, int c)\n{\n    for(int row = 0; row < r; row++)\n    {\n        for(int col = 0; col < c; col++)\n        {\n            sum[row*c+col] = a[row*c+col] + b[row*c+col];\n        }\n    }\n}\n\nvoid subtract(double* a, double* b, double* diff, int r, int c)\n{\n    for(int row = 0; row < r; row++)\n    {\n        for(int col = 0; col < c; col++)\n        {\n            diff[row*c+col] = a[row*c+col] - b[row*c+col];\n        }\n    }\n}\n\nvoid product(double* m1, double* m2, double* prod, int row1, int col1, int col2)\n{\n    for (int i = 0; i < row1; i++) \n    {\n        for (int j = 0; j < col2; j++) \n        {\n            prod[i*col2+j] = 0;\n\n            for (int k = 0; k < col1; k++)\n                prod[i*col2+j] += m1[i*col1+k] * m2[k*col2+j];\n        }\n    }\n}\n\nvoid transpose(double* a, int r, int c)\n{\n    for(int row = 0; row < r; row++)\n    {\n        for(int col = row+1; col < c; col++)\n        {\n\t\t\tdouble temp = a[col*r+row];\n            a[col*r+row] = a[row*c+col];\n\t\t\ta[row*c+col] = temp;\n        }\n    }\n}\n\ndouble maxCoeff(double* a, int r, int c)\n{\n    double max = fabs(a[0]); \n    for(int row = 0; row < r; row++)\n    {\n        for(int col = 0; col < c; col++)\n        {\n            if(fabs(a[row*c+col]) > max)\n                max = fabs(a[row*c+col]);\n        }\n    }\n    return max;\n}\n\n//inspired by https://github.com/TakaHoribe/Riccati_Solver/blob/master/riccati_solver.cpp\nbool solveRiccatiIterationD(double* A, double* B, double* Q, double* R, double* P, double* P_next) \n{\n    int iter_max = 100000;\n    double tolerance = 1E-7;\n    memcpy(P, Q, STATES*STATES*sizeof(double));// initialize\n\n    //buffers\n\tdouble AtP[STATES*STATES];\n\tdouble AtPA[STATES*STATES];\n\tdouble AtPB[STATES*OUTPUTS];\n\tdouble BtP[OUTPUTS*STATES];\n\tdouble BtPB[OUTPUTS*OUTPUTS];\n\tdouble RPlusBtPBInv[OUTPUTS];\n    double AtPBRPlusBtPBInv[STATES*OUTPUTS];\n\tdouble AtPBRPlusBtPBInvBt[STATES*STATES];\n\tdouble AtPBRPlusBtPBInvBtP[STATES*STATES];\n\tdouble AtPBRPlusBtPBInvBtPA[STATES*STATES];\n\tdouble diff[STATES*STATES];\n\n    for (int i = 0; i < iter_max; ++i) \n    {\n        // -- discrete solver --\n        product(At, P, AtP, STATES, STATES, STATES);\n        product(AtP, A, AtPA, STATES, STATES, STATES);\n        \n        product(AtP, B, AtPB, STATES, STATES, OUTPUTS);\n        product(Bt, P, BtP, OUTPUTS, STATES, STATES);\n        product(BtP, B, BtPB, OUTPUTS, STATES, OUTPUTS);\n        RPlusBtPBInv[0] = 1.0/(R[0]+BtPB[0]);//since R is a 1x1 matrix the inverse of RPlusBtPiB must be 1/RPlusBtPiB\n        \n        product(AtPB, RPlusBtPBInv, AtPBRPlusBtPBInv, STATES, OUTPUTS, OUTPUTS);\n        product(AtPBRPlusBtPBInv, Bt, AtPBRPlusBtPBInvBt, STATES, OUTPUTS, STATES);\n        product(AtPBRPlusBtPBInvBt, P, AtPBRPlusBtPBInvBtP, STATES, STATES, STATES);\n        product(AtPBRPlusBtPBInvBtP, A, AtPBRPlusBtPBInvBtPA, STATES, STATES, STATES);\n        \n        subtract(AtPA, AtPBRPlusBtPBInvBtPA, diff, STATES, STATES);\n        add(diff, Q, P_next, STATES, STATES);\n        \n        subtract(P_next, P, P, STATES, STATES);\n        \n        double diff = fabs(maxCoeff(P, STATES, STATES));\n        memcpy(P, P_next, STATES*STATES*sizeof(double));\n        if (diff < tolerance) {\n            return true;\n        }\n    }\n    return false; // over iteration limit\n}\n\nvoid dlqr(double* A, double* B, double* Q, double* R)\n{\n    double P[STATES*STATES];\n    double P_next[STATES*STATES];\n    solveRiccatiIterationD(A, B, Q, R, P, P_next);\n    \n    //compute the LQR gain\n    //K = np.matrix(scipy.linalg.inv(B.T*X*B+R)*(B.T*X*A))\n    double BtP[OUTPUTS*STATES];\n    double BtPB[OUTPUTS*OUTPUTS];\n    double BtPBPlusRInv[OUTPUTS*OUTPUTS];\n    double BtPA[OUTPUTS*STATES];\n    product(Bt, P, BtP, OUTPUTS, STATES, STATES);\n    product(BtP, B, BtPB, OUTPUTS, STATES, OUTPUTS);\n    BtPBPlusRInv[0] = 1/(BtPB[0] + R[0]);\n\n    product(BtP, A, BtPA, OUTPUTS, STATES, STATES);\n    product(BtPBPlusRInv, BtPA, gains, OUTPUTS, OUTPUTS, STATES);\n}\n\nvoid setRPM(double val, double offset)\n{\n    LeftMotor.setVelocity(val-offset, rpm);\n    RightMotor.setVelocity(val+offset, rpm);\n    LeftMotor.spin(forward);\n    RightMotor.spin(forward);\n    //wait(dt,seconds);//allow motors to react\n}\n\nvoid accelerate(double currentRPM, double accel, double offset)\n{\n    double currentVel = currentRPM * RPM_TO_MPS;\n    double targetVel = currentVel + accel*dt;\n    setRPM( targetVel/RPM_TO_MPS, offset );\n}\n\nvoid react(double steering)\n{\n    //control is position, velocity, angle, angular velocity\n    //median filter of roll\n    int filterSize = 11;\n    double samples[filterSize];\n    for(int n = 0; n < filterSize; n++)\n    {\n      //the value of Balance.roll() should produce positives when your robot tilts forward\n      //if not then multiply it by -1 AND multiply your target angle by -1\n      samples[n] = Balance.pitch();//check orientation\n    }\n    std::sort(samples, samples + filterSize);\n\n    double roll = samples[filterSize/2];//choose median of data\n    //double roll = Balance.pitch();\n    actualState[ANGLE] = DEGREES_TO_RADIANS*(roll);\n    if(fabs(actualState[ANGLE]) > MAX_TILT)//fallen over?\n    {\n        setRPM(0, 0);\n    }\n\n    //this value should produce positives when your robot tilts forward\n    //if not then multiply it by -1\n    actualState[ANGULAR_VELOCITY] = DEGREES_TO_RADIANS*Balance.gyroRate(yaxis,dps);\n    \n    actualState[POSITION] = CIRCUMFERENCE*(LeftMotor.position(turns)+RightMotor.position(turns))/2.0;\n    double currentRPM = (LeftMotor.velocity(rpm)+RightMotor.velocity(rpm))/2.0;\n    actualState[VELOCITY] = RPM_TO_MPS*currentRPM;\n    \n    double accel = 0;\n    for(int n = 0; n < STATES; n++)\n    {\n        errorState[n] = desiredState[n]-actualState[n];\n        accel += errorState[n]*gains[n];            \n    }            \n\n    accelerate( currentRPM, accel, steering );\n}\n\nvoid countDown(int sec)\n{\n    for(int count = sec; count > 0; count--)\n    {\n        Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1,1);\n        Brain.Screen.print(\"Program starting in %d...           \", count);\n        wait(1,seconds);\n    }\n    Brain.Screen.clearScreen();\n}\n\nvoid calibrate()\n{\n    wait(1, seconds);//pressing screen to run can wobble sensor\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Calibrating Inertial Sensor...          \");\n\n    Balance.startCalibration();\n    while(Balance.isCalibrating())\n    {\n        wait(0.01, seconds);\n    }\n    Brain.Screen.clearScreen();\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Calibration complete           \");\n\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.print(\"Touch X Button to begin...            \");\n    while(!Controller1.ButtonX.pressing())\n    {\n        wait(0.01, seconds);\n    }\n\n    countDown(3);\n}\n\nvoid showParameters()\n{\n    Controller1.Screen.setCursor(1,1);\n    Controller1.Screen.print(\"L=%.3f R=%.3f\", l, maxAcc/RPM_TO_MPS);\n    Controller1.Screen.setCursor(2,1);\n    Controller1.Screen.print(\"p=%.3f v=%.3f  \", gains[POSITION], gains[VELOCITY]);\n    Controller1.Screen.setCursor(3,1);\n    Controller1.Screen.print(\"a=%.3f av=%.3f\", gains[ANGLE], gains[ANGULAR_VELOCITY]);  \n}\n\nvoid adjustParameters()\n{\n    int sensitivity = 5;\n    if(abs(Controller1.Axis3.position()) > sensitivity)\n        l += Controller1.Axis3.position()/10000.0;\n    \n    if(Controller1.ButtonUp.pressing())\n        l += 0.001;\n\n    if(Controller1.ButtonDown.pressing())\n        l -= 0.001;\n    \n    if(l < 0.01)//1cm? probably not but stop here anyway\n        l = 0.01;\n\n    if(abs(Controller1.Axis2.position()) > sensitivity)//fine tuning\n    {\n        maxAcc += Controller1.Axis2.position()/10000.0;\n        R[OUTPUTS*OUTPUTS] = { 1/(maxAcc*maxAcc) };\n    }\n    \n    showParameters();\n}\n\nvoid haltAndChange()\n{\n    setRPM(0, 0);\n    while(Controller1.ButtonX.pressing())//wait until the user let's go of the button\n    {\n        wait(0.01, seconds);\n    }\n\n    while(!Controller1.ButtonX.pressing())\n    {\n        adjustParameters();\n    }\n\n    errorState[POSITION] = 0;\n    errorState[VELOCITY] = 0;\n    errorState[ANGLE] = 0;\n    errorState[ANGULAR_VELOCITY] = 0;\n    LeftMotor.setPosition(0,turns);\n    RightMotor.setPosition(0,turns);\n    \n    updateStateSpace();\n    dlqr(A, B, Q, R);\n    countDown(3);//time to set up after changing the values\n\n    showParameters();//about to go to live testing\n}\n\ndouble joystick()\n{\n    double scale = 100/MAX_VELOCITY;//axis is from -100 to 100 this maps the values according to MAX_VELOCITY\n    double speed = (Controller1.Axis2.position()+Controller1.Axis3.position())/2.0;\n    desiredState[VELOCITY] = speed/scale;\n    \n    if(fabs(desiredState[VELOCITY])>1e-5)//moving will change the position so assume the current position is the desired one (implied by the velocity)\n    {\n        desiredState[POSITION] = CIRCUMFERENCE*(LeftMotor.position(turns)+ RightMotor.position(turns))/2.0;\n    }\n\n    double steering = (Controller1.Axis2.position()-Controller1.Axis3.position())/2.0;\n    return steering;\n}\nint turnCount = 0;\nconst int MAX_TURNS = 500;\nbool resting = false;\nvoid hunt()\n{\n  double danger = 300;\n  if(DistanceSensor.distance(mm) < danger)\n  {\n    double scale = 100/MAX_VELOCITY;//axis is from -100 to 100 this maps the values according to MAX_VELOCITY\n    double speed = 50;\n    desiredState[VELOCITY] = speed/scale;\n    if(fabs(desiredState[VELOCITY])>1e-5)//moving will change the position so assume the current position is the desired one (implied by the velocity)\n    {\n        desiredState[POSITION] = CIRCUMFERENCE*(LeftMotor.position(turns)+ RightMotor.position(turns))/2.0;\n    }\n    react(0);\n  }\n  else if(DistanceSensor2.distance(mm) < danger)\n  {\n    double scale = 100/MAX_VELOCITY;//axis is from -100 to 100 this maps the values according to MAX_VELOCITY\n    double speed = -50;\n    desiredState[VELOCITY] = speed/scale;\n    if(fabs(desiredState[VELOCITY])>1e-5)//moving will change the position so assume the current position is the desired one (implied by the velocity)\n    {\n        desiredState[POSITION] = CIRCUMFERENCE*(LeftMotor.position(turns)+ RightMotor.position(turns))/2.0;\n    }\n    react(0);\n  }\n  else\n  {\n    if(!resting)\n    {\n      desiredState[VELOCITY] = 0;\n      react(5);\n      turnCount++;\n      if(turnCount > MAX_TURNS)\n      {\n        resting = true;\n        Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1,1);\n        Brain.Screen.print(\"Rotating\");\n        turnCount = 0;\n      }\n    }\n    else\n    {\n      desiredState[VELOCITY] = 0;\n      react(0);  \n      turnCount++;\n      if(turnCount > MAX_TURNS)\n      {\n        resting = false;\n        Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1,1);\n        Brain.Screen.print(\"Not Rotating\");\n        turnCount = 0;\n      }    \n    }\n  }\n}\n \nint main()\n{    \n    updateStateSpace();\n    dlqr(A, B, Q, R);\n    showParameters();\n    calibrate();\n\n    Brain.Timer.clear();\n    while(Brain.Timer.time(seconds)<5)\n    {\n      double scale = 100/MAX_VELOCITY;//axis is from -100 to 100 this maps the values according to MAX_VELOCITY\n      double speed = 25;\n      desiredState[VELOCITY] = speed/scale;\n      if(fabs(desiredState[VELOCITY])>1e-5)//moving will change the position so assume the current position is the desired one (implied by the velocity)\n      {\n          desiredState[POSITION] = CIRCUMFERENCE*(LeftMotor.position(turns)+ RightMotor.position(turns))/2.0;\n      }\n      react(0);\n    }\n\n    while(true)\n    {\n       // react(0);\n        hunt();\n        /* if(Controller1.ButtonX.pressing())\n        {\n            haltAndChange();\n        }\n        else\n        {\n            hunt();\n        } */\n    }\n}\n\n\n","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[12],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[19],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[20],"name":"Balance","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1,2],"name":"DistanceSensor","customName":true,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7,8],"name":"DistanceSensor2","customName":true,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{"id":"partner"},"triportSourcePort":22}],"slot":4,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}