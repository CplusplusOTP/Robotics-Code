{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor LeftMotor = motor(PORT12, ratio18_1, false);\n\nmotor RightMotor = motor(PORT19, ratio18_1, true);\n\ninertial Balance = inertial(PORT20);\n\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n//change your targetAngle, length to center of mass and possibly your wheel circumference\nconst double CIRCUMFERENCE = 4.0*0.0254*M_PI;//4\" wheel to m\ndouble targetAngle = 0.3;//in degrees - so is the sensor for measuring error state\ndouble l = 0.5058;//length of (uniform) beam ie. your pendulum\ndouble m = 2.3944;//mass of pendulum\ndouble mC = 0.9548;//mass of cart\ndouble M = m + mC; //3.3493\n\n//all units are in radians\nconst double MAX_TILT = M_PI/6;//30 degrees\nconst double RPM_TO_MPS = CIRCUMFERENCE/60.0;//PI * diameter in m\nconst double DEGREES_TO_RADIANS = M_PI / 180.0;\nconst double dt = 0.01;//10ms for motor pid to react (200Hz)\nconst double dtSqr = dt*dt;\nconst double G = 9.81;\n\n//K = {position, velocity, angle, angular velocity}\n//make sure your sensor values match the implied response\n//For example, if a positive angle has a positive gain then forward (positive) should be the correct direction for restoring equilibrium\nconst int POSITION = 0;\nconst int VELOCITY = 1;\nconst int ANGLE = 2;\nconst int ANGULAR_VELOCITY = 3;\nconst int STATES = 4;\nconst int OUTPUTS = 1;\ndouble gains[STATES*OUTPUTS] = {0, 0, 0, 0};\n\ndouble actualState[STATES] = {0, 0, 0, 0};\ndouble desiredState[STATES] = {0, 0, 0, 0};\ndouble errorState[STATES] = {0, 0, 0, 0};\n\ndouble A[STATES*STATES];\ndouble At[STATES*STATES];\ndouble B[STATES*OUTPUTS];\ndouble Bt[OUTPUTS*STATES];\n\n//tune maxP, maxV, maxA, maxAV, qScale\n//all things being equal, describe the penalty for the errors\n//In the default the interpretation is that:\n//the position being off by 1cm is the same significance as the robot moving 1cm/s being tilted 0.1 degrees and the robot rotating 2degrees/sec\n//qScale can be tuned first to magnify or reduce the reaction\ndouble maxP = 0.15;\ndouble maxV = 0.1;\ndouble maxA = 0.05*M_PI/180;\ndouble maxAV = 10*maxA;\ndouble qScale = 1;\ndouble Q[STATES*STATES] = {  \n                    qScale/(maxP*maxP), 0, 0, 0, \n                    0, qScale/(maxV*maxV), 0, 0,\n                    0, 0, qScale/(maxA*maxA), 0,\n                    0, 0, 0, qScale/(maxAV*maxAV)};\n\n//tune maxAcc and rScale\ndouble maxAcc = 50*RPM_TO_MPS;//a change of 30 rpms is the default\ndouble rScale = 1;\ndouble R[OUTPUTS*OUTPUTS] = { rScale/(maxAcc*maxAcc) };\n\n//adapted from https://sharpneat.sourceforge.io/research/cart-pole/cart-pole-equations.html\n//equations (27 & 28 k = 1/3 no friction)\nvoid updateStateSpace()\n{\n    //recalculate state matrices\n    double theta = errorState[ANGLE];//-pi/2 to pi/2 becomes -pi/12 to pi/12\n    double thetaDot = errorState[ANGULAR_VELOCITY];\n    \n    double j,k,den,p,q,r;\n    if(fabs(errorState[ANGLE]) < 1e-7)//sin(theta)/theta -> 1\n    {\n        j = 3*G/(4*l);\n        k = 3*cos(theta)/(4*l);\n        den = m*cos(theta)*cos(theta)-4*M/3.0;\n        p = m*G*cos(theta)/den;\n        q = 4*mC/(3*den);\n        r = 4*m*l*thetaDot*sin(theta)/(3*den);\n    }\n\n    else\n    {\n        j = 3*G*sin(theta)/(4*l*theta);\n        k = 3*cos(theta)/(4*l);\n        den = m*cos(theta)*cos(theta)-4*M/3.0;\n        p = m*G*sin(theta)*cos(theta)/(theta*den);\n        q = 4*mC/(3*den);\n        r = 4*m*l*thetaDot*sin(theta)/(3*den);\n    }\n\n    /*\n        error -r*thetaDot*dt should just be -r*dt\n        double tempA[STATES*STATES] = {   \n                    1, dt, 0.5*p*dtSqr, -0.5*r*dtSqr,\n                    0, 1, p*dt, -r*thetaDot*dt,\n                    0, 0, 1+(0.5*j-0.5*k*p)*dtSqr, dt+0.5*k*r*dtSqr,\n                    0, 0, (j-k*p)*dt, 1+k*r*dt};\n\n        double tempAt[STATES*STATES] = {\n                    1, 0, 0, 0,\n                    dt, 1, 0, 0,\n                    0.5*p*dtSqr, p*dt, 1+(0.5*j-0.5*k*p)*dtSqr, (j-k*p)*dt,\n                    -0.5*r*dtSqr, -r*thetaDot*dt, dt+0.5*k*r*dtSqr, 1+k*r*dt};\n                    */\n    double tempA[STATES*STATES] = {   \n                    1, dt, 0.5*p*dtSqr, -0.5*r*dtSqr,\n                    0, 1, p*dt, -r*dt,\n                    0, 0, 1+(0.5*j-0.5*k*p)*dtSqr, dt+0.5*k*r*dtSqr,\n                    0, 0, (j-k*p)*dt, 1+k*r*dt};\n\n    double tempAt[STATES*STATES] = {\n                    1, 0, 0, 0,\n                    dt, 1, 0, 0,\n                    0.5*p*dtSqr, p*dt, 1+(0.5*j-0.5*k*p)*dtSqr, (j-k*p)*dt,\n                    -0.5*r*dtSqr, -r*dt, dt+0.5*k*r*dtSqr, 1+k*r*dt};\n                                \n    double tempB[STATES*OUTPUTS] = {   \n                    -0.5*q*dtSqr,\n                    -q*dt,\n                    0.5*k*q*dtSqr,\n                    k*q*dt};\n    double tempBt[OUTPUTS*STATES] = { -0.5*q*dtSqr, -q*dt, 0.5*k*q*dtSqr, k*q*dt};\n    \n    memcpy(A, tempA, STATES*STATES*sizeof(double));\n    memcpy(At, tempAt, STATES*STATES*sizeof(double));                            \n    memcpy(B, tempB, STATES*OUTPUTS*sizeof(double));\n    memcpy(Bt, tempBt, OUTPUTS*STATES*sizeof(double));\n}\n\nvoid add(double* a, double* b, double* sum, int r, int c)\n{\n    for(int row = 0; row < r; row++)\n    {\n        for(int col = 0; col < c; col++)\n        {\n            sum[row*c+col] = a[row*c+col] + b[row*c+col];\n        }\n    }\n}\n\nvoid subtract(double* a, double* b, double* diff, int r, int c)\n{\n    for(int row = 0; row < r; row++)\n    {\n        for(int col = 0; col < c; col++)\n        {\n            diff[row*c+col] = a[row*c+col] - b[row*c+col];\n        }\n    }\n}\n\nvoid product(double* m1, double* m2, double* prod, int row1, int col1, int col2)\n{\n    for (int i = 0; i < row1; i++) \n    {\n        for (int j = 0; j < col2; j++) \n        {\n            prod[i*col2+j] = 0;\n\n            for (int k = 0; k < col1; k++)\n                prod[i*col2+j] += m1[i*col1+k] * m2[k*col2+j];\n        }\n    }\n}\n\nvoid transpose(double* a, int r, int c)\n{\n    for(int row = 0; row < r; row++)\n    {\n        for(int col = row+1; col < c; col++)\n        {\n\t\t\tdouble temp = a[col*r+row];\n            a[col*r+row] = a[row*c+col];\n\t\t\ta[row*c+col] = temp;\n        }\n    }\n}\n\ndouble maxCoeff(double* a, int r, int c)\n{\n    double max = fabs(a[0]); \n    for(int row = 0; row < r; row++)\n    {\n        for(int col = 0; col < c; col++)\n        {\n            if(fabs(a[row*c+col]) > max)\n                max = fabs(a[row*c+col]);\n        }\n    }\n    return max;\n}\n\n//inspired by https://github.com/TakaHoribe/Riccati_Solver/blob/master/riccati_solver.cpp\nint solveRiccatiIterationD(double* A, double* B, double* Q, double* R, double* P, double* P_next) \n{\n    int iter_max = 100000;\n    double tolerance = 1E-7;\n    memcpy(P, Q, STATES*STATES*sizeof(double));// initialize\n\n    //buffers\n\tdouble AtP[STATES*STATES];\n\tdouble AtPA[STATES*STATES];\n\tdouble AtPB[STATES*OUTPUTS];\n\tdouble BtP[OUTPUTS*STATES];\n\tdouble BtPB[OUTPUTS*OUTPUTS];\n\tdouble RPlusBtPBInv[OUTPUTS];\n    double AtPBRPlusBtPBInv[STATES*OUTPUTS];\n\tdouble AtPBRPlusBtPBInvBt[STATES*STATES];\n\tdouble AtPBRPlusBtPBInvBtP[STATES*STATES];\n\tdouble AtPBRPlusBtPBInvBtPA[STATES*STATES];\n\tdouble diff[STATES*STATES];\n\n    for (int i = 0; i < iter_max; ++i) \n    {\n        // -- discrete solver --\n        product(At, P, AtP, STATES, STATES, STATES);\n        product(AtP, A, AtPA, STATES, STATES, STATES);\n        \n        product(AtP, B, AtPB, STATES, STATES, OUTPUTS);\n        product(Bt, P, BtP, OUTPUTS, STATES, STATES);\n        product(BtP, B, BtPB, OUTPUTS, STATES, OUTPUTS);\n        RPlusBtPBInv[0] = 1.0/(R[0]+BtPB[0]);//since R is a 1x1 matrix the inverse of RPlusBtPiB must be 1/RPlusBtPiB\n        \n        product(AtPB, RPlusBtPBInv, AtPBRPlusBtPBInv, STATES, OUTPUTS, OUTPUTS);\n        product(AtPBRPlusBtPBInv, Bt, AtPBRPlusBtPBInvBt, STATES, OUTPUTS, STATES);\n        product(AtPBRPlusBtPBInvBt, P, AtPBRPlusBtPBInvBtP, STATES, STATES, STATES);\n        product(AtPBRPlusBtPBInvBtP, A, AtPBRPlusBtPBInvBtPA, STATES, STATES, STATES);\n        \n        subtract(AtPA, AtPBRPlusBtPBInvBtPA, diff, STATES, STATES);\n        add(diff, Q, P_next, STATES, STATES);\n        \n        subtract(P_next, P, P, STATES, STATES);\n        \n        double diff = maxCoeff(P, STATES, STATES);\n        memcpy(P, P_next, STATES*STATES*sizeof(double));\n        if (diff < tolerance) {\n            return i;\n        }\n    }\n    return -1; // over iteration limit\n}\n\nint dlqr(double* A, double* B, double* Q, double* R)\n{\n    double P[STATES*STATES];\n    double P_next[STATES*STATES];\n    int iter = solveRiccatiIterationD(A, B, Q, R, P, P_next);\n    \n    //compute the LQR gain\n    //K = np.matrix(scipy.linalg.inv(B.T*X*B+R)*(B.T*X*A))\n    double BtP[OUTPUTS*STATES];\n    double BtPB[OUTPUTS*OUTPUTS];\n    double BtPBPlusRInv[OUTPUTS*OUTPUTS];\n    double BtPA[OUTPUTS*STATES];\n    product(Bt, P, BtP, OUTPUTS, STATES, STATES);\n    product(BtP, B, BtPB, OUTPUTS, STATES, OUTPUTS);\n    BtPBPlusRInv[0] = 1/(BtPB[0] + R[0]);\n\n    product(BtP, A, BtPA, OUTPUTS, STATES, STATES);\n    product(BtPBPlusRInv, BtPA, gains, OUTPUTS, OUTPUTS, STATES);\n    gains[POSITION] *= -1;\n    gains[VELOCITY] *= -1; \n    gains[ANGLE] *= -1; \n    return iter;\n}\n\nvoid setRPM(double val)\n{\n    LeftMotor.setVelocity(val, rpm);\n    RightMotor.setVelocity(val, rpm);\n    LeftMotor.spin(forward);\n    RightMotor.spin(forward);\n    //wait(dt,seconds);//allow motors to react - program seems to take about 10ms to react\n}\n\nvoid accelerate(double currentRPM, double accel)\n{\n    double currentVel = currentRPM * RPM_TO_MPS;\n    double targetVel = currentVel + accel*dt;\n    setRPM( targetVel/RPM_TO_MPS );\n    //Controller1.Screen.clearLine(1);\n    //Controller1.Screen.setCursor(1,1);\n    //Controller1.Screen.print(targetVel/RPM_TO_MPS);\n}\n\nvoid react()\n{\n    //control is position, velocity, angle, angular velocity\n    double roll = Balance.pitch();\n    if(fabs(actualState[ANGLE]) > MAX_TILT)//fallen over?\n    {\n        setRPM(0);\n    }\n    \n    actualState[ANGLE] = DEGREES_TO_RADIANS*(targetAngle-roll);\n    actualState[ANGULAR_VELOCITY] = DEGREES_TO_RADIANS*Balance.gyroRate(yaxis,dps);\n    actualState[POSITION] = CIRCUMFERENCE*(LeftMotor.position(turns)+RightMotor.position(turns))/2.0;\n    double currentRPM = (LeftMotor.velocity(rpm)+RightMotor.velocity(rpm))/2.0;\n    actualState[VELOCITY] = RPM_TO_MPS*currentRPM;\n    \n    double accel = 0;\n    for(int n = 0; n < STATES; n++)\n    {\n        errorState[n] = desiredState[n]-actualState[n];\n        accel += errorState[n]*gains[n];            \n    }            \n\n    accelerate( currentRPM, accel );\n}\n\nvoid countDown(int sec)\n{\n    for(int count = sec; count > 0; count--)\n    {\n        Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1,1);\n        Brain.Screen.print(\"Program starting in %d...           \", count);\n        wait(1,seconds);\n    }\n    Brain.Screen.clearScreen();\n}\n\nvoid calibrate()\n{\n    wait(1, seconds);//pressing screen to run can wobble sensor\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Calibrating Inertial Sensor...          \");\n\n    Balance.startCalibration();\n    while(Balance.isCalibrating())\n    {\n        wait(0.01, seconds);\n    }\n    Brain.Screen.clearScreen();\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Calibration complete           \");\n\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.print(\"Touch Y Button to begin...            \");\n    while(!Controller1.ButtonY.pressing())\n    {\n        wait(0.01, seconds);\n    }\n\n    countDown(3);\n}\n\nvoid showParameters()\n{\n    Controller1.Screen.setCursor(1,1);\n    Controller1.Screen.print(\"Center=%.4f\", l);\n    Controller1.Screen.setCursor(2,1);\n    Controller1.Screen.print(\"p=%.3f v=%.3f  \", gains[POSITION], gains[VELOCITY]);\n    Controller1.Screen.setCursor(3,1);\n    Controller1.Screen.print(\"a=%.3f av=%.3f\", gains[ANGLE], gains[ANGULAR_VELOCITY]);  \n}\n\nvoid adjustParameters()\n{\n    int sensitivity = 5;\n    if(abs(Controller1.Axis3.position()) > sensitivity)\n        l += Controller1.Axis3.position()/10000.0;\n        \n    if(abs(Controller1.Axis2.position()) > sensitivity)//fine tuning\n        l += Controller1.Axis2.position()/100000.0;\n    \n    if(Controller1.ButtonUp.pressing())\n        l += 0.001;\n\n    if(Controller1.ButtonDown.pressing())\n        l -= 0.001;\n    \n    if(l < 0.01)//1cm? probably not but stop here anyway\n        l = 0.01;\n\n    showParameters();\n}\n\nvoid haltAndChange()\n{\n    setRPM(0);\n    while(Controller1.ButtonX.pressing())//wait until the user let's go of the button\n    {\n        wait(0.01, seconds);\n    }\n\n    while(!Controller1.ButtonX.pressing())\n    {\n        adjustParameters();\n    }\n\n    errorState[POSITION] = 0;\n    errorState[VELOCITY] = 0;\n    errorState[ANGLE] = 0;\n    errorState[ANGULAR_VELOCITY] = 0;\n    LeftMotor.setPosition(0,turns);\n    RightMotor.setPosition(0,turns);\n    \n    updateStateSpace();\n    dlqr(A, B, Q, R);\n    \n    countDown(3);//time to set up after changing the values\n    showParameters();//about to go to live testing\n}\n\nint main() \n{    \n    updateStateSpace();\n    dlqr(A, B, Q, R);\n    showParameters();\n    calibrate();\n    while(true)\n    {\n        if(Controller1.ButtonX.pressing())\n        {\n            haltAndChange();\n        }\n        else\n        {            \n            react();\n        }\n    }\n    \n}\n\n\n","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[12],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[19],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[20],"name":"Balance","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}