{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor LeftMotor = motor(PORT12, ratio18_1, false);\n\nmotor RightMotor = motor(PORT19, ratio18_1, true);\n\ninertial Balance = inertial(PORT20);\n\nsonar RangeFinderA = sonar(Brain.ThreeWirePort.A);\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nconst double MAX_TILT = 30;//robot has failed, program aborts over this threshold\n\n//PID parameters/variables to test - mine are on carpet (to reduce the concern of slippage)\ndouble targetAngle = 0.3;//0.3,0.5, -0.5, -2//originally 11.3 but tuned to 11.1, then modified center of gravity -> 7.6\ndouble kP = 30.0;//how fast we react to the observed error - in this case the tilt\ndouble kI = 0.0;//our reaction will have some residual error still in the system, this term reacts to the \"build up\" that is happening\ndouble kD = 8.0;//if we measure our reaction, in terms of how well it performed from the last observed error, this variable will adjust our reaction accordingly\ndouble waitTime = 0.004;//4ms\n\n//inititalize readings\ndouble travel = 0;//travel of the encoders for testing metric\ndouble prevPosition = 0;\n\nstruct State{\n  double angle;\n  double rate;\n  double distance;\n};\n\nState setPoint = {targetAngle,0,0};\nvoid setRPM(double val)\n{\n    double currentPosition = (LeftMotor.position(degrees)+RightMotor.position(degrees))/2.0;\n    //note circumference is not necessary here because we use the travel with the I term and multiple. \n    //integral = kI * rotations * circumference which is equivalent to integral = kI * rotations for some other kI\n    travel += currentPosition - prevPosition;//update travel before direction (possibly) changes\n    prevPosition = currentPosition;\n\n    LeftMotor.setVelocity(val, rpm);\n    RightMotor.setVelocity(val, rpm);\n    LeftMotor.spin(forward);\n    RightMotor.spin(forward);\n    wait(waitTime, seconds);//allow motors to react\n}\n\nvoid runPID()\n{\n    double error = setPoint.angle - Balance.pitch();\n    if(fabs(error) > MAX_TILT)//fallen over?\n      setRPM(0);\n\n    else\n    {\n        double integral = setPoint.distance - travel;\n        double derivative = setPoint.rate - Balance.gyroRate(yaxis, dps);           \n        \n        //assumes motors move the robot forward\n        //assumes a positive angle is when the robot tips forward\n        //when error is positive the motors should also be positive to correct error - add\n        //when integral is positive, the robot's current location has not reached the goal, robot should move forward - add\n        //when the derivative is negative the robot is falling more than the goal, the correction should be positive (robot moves forward) to decrease the rate it falls - subtract\n        double response = -kP * error + kI * integral - kD * derivative;\n        setRPM(response);\n    }\n}\n\nvoid showParameters()\n{\n    Controller1.Screen.clearScreen();\n    Controller1.Screen.setCursor(1,1);\n    Controller1.Screen.print(\"kP= %.3f   \", kP);\n    Controller1.Screen.setCursor(2,1);\n    Controller1.Screen.print(\"kI= %.4f, kD= %.3f   \", kI, kD);\n    Controller1.Screen.setCursor(3,1);\n    Controller1.Screen.print(\"tA= %.2f, wT= %.2f   \", targetAngle, waitTime*1000); \n    wait(0.1,seconds);   \n}\n\nvoid adjustPID()\n{\n    double scale = 100.0;\n    int sensitivity = 5;\n    if(abs(Controller1.Axis3.position()) > sensitivity)\n    {\n        kP += Controller1.Axis3.position()/scale;\n        if(kP < 0)\n            kP = 0;\n    }\n\n    if(abs(Controller1.Axis2.position()) > sensitivity)\n    {\n        kD += Controller1.Axis2.position()/(2*scale);//slower change for kD\n        if(kD < 0)\n            kD = 0;\n    }\n\n    if(Controller1.ButtonL1.pressing())\n        kI += 0.0001;\n    else if(Controller1.ButtonL2.pressing())\n        kI -= 0.0001;\n    if(kI < 0)\n        kI = 0;\n\n    if(Controller1.ButtonR1.pressing())\n        targetAngle += 0.01;\n    else if(Controller1.ButtonR2.pressing())\n        targetAngle -= 0.01;\n\n    if(Controller1.ButtonUp.pressing())\n        waitTime += 0.0001;\n    else if(Controller1.ButtonDown.pressing())\n        waitTime -= 0.0001;\n    if(waitTime < 0)\n        waitTime = 0;\n\n    showParameters();\n}\n\nvoid countDown(int sec)\n{\n    for(int count = sec; count > 0; count--)\n    {\n        Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1,1);\n        Brain.Screen.print(\"Program starting in %d...           \", count);\n        wait(1,seconds);\n    }\n    Brain.Screen.clearScreen();\n}\n\nvoid calibrate()\n{\n    wait(1, seconds);//pressing screen to run can wobble sensor\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Calibrating Inertial Sensor...          \");\n\n    Balance.startCalibration();\n    while(Balance.isCalibrating())\n    {\n        wait(0.01, seconds);\n    }\n    Brain.Screen.clearScreen();\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Calibration complete           \");\n\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.print(\"Touch Y Button to begin...            \");\n    while(!Controller1.ButtonY.pressing())\n    {\n        wait(0.01, seconds);\n    }\n\n    countDown(3);\n}\n\nvoid haltAndChange()\n{\n    setRPM(0);\n    while(Controller1.ButtonX.pressing())//wait until the user let's go of the button\n    {\n        wait(0.01, seconds);\n    }\n\n    while(!Controller1.ButtonX.pressing())\n    {\n        adjustPID();\n    }\n\n    countDown(3);//time to set up after changing the values\n    showParameters();//about to go to live testing\n    travel = 0;//reset encoder metric\n    prevPosition = 0;\n    LeftMotor.setPosition(0, turns);\n    RightMotor.setPosition(0, turns);\n}\n\nint main() \n{    \n    calibrate();\n    showParameters();\n    while(true)\n    {\n        if(Controller1.ButtonX.pressing())\n        {\n            haltAndChange();\n        }\n        else\n        { \n            runPID();\n        }\n    }\n}\n","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[12],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[19],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[20],"name":"Balance","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1,2],"name":"RangeFinderA","customName":false,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{"id":"partner"},"triportSourcePort":22}],"slot":1,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}